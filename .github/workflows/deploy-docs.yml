name: Deploy OmniFetch Documentation

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    name: Lint and Test Documentation
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Node.js for markdownlint
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install markdownlint-cli
      run: |
        npm install -g markdownlint-cli markdownlint-cli2
        echo "âœ“ Markdownlint installed successfully"
    
    - name: Lint Markdown files
      run: |
        echo "ðŸ” Running markdown linting..."
        markdownlint docs/**/*.md --config .markdownlint.yml
        echo "âœ… Markdown linting passed"
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: requirements.txt
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        echo "âœ“ Python dependencies installed"
    
    - name: Validate MkDocs configuration
      run: |
        echo "ðŸ”§ Validating MkDocs configuration..."
        python -c "
        import yaml
        import sys
        
        # Custom YAML loader that ignores MkDocs-specific tags
        class MkDocsYAMLLoader(yaml.SafeLoader):
            pass
        
        # Add constructor to ignore !ENV tag
        def env_constructor(loader, node):
            # Return empty string for ENV tags during validation
            return ''
        
        # Add constructor to ignore Python object references
        def python_constructor(loader, node):
            # Return the string representation for Python objects
            return str(node.value)
        
        # Add multi-constructor for generic python tags (requires different signature)
        def python_multi_constructor(loader, tag_suffix, node):
            # Return the string representation for any Python object
            return str(node.value)
        
        # Register all MkDocs-specific tag constructors
        MkDocsYAMLLoader.add_constructor('!ENV', env_constructor)
        MkDocsYAMLLoader.add_constructor('tag:yaml.org,2002:python/name:material.extensions.emoji.to_svg', python_constructor)
        MkDocsYAMLLoader.add_constructor('tag:yaml.org,2002:python/name:material.extensions.emoji.twemoji', python_constructor)
        MkDocsYAMLLoader.add_constructor('tag:yaml.org,2002:python/name:pymdownx.superfences.fence_code_format', python_constructor)
        
        # Add a generic handler for any python/name tags we might have missed
        MkDocsYAMLLoader.add_multi_constructor('tag:yaml.org,2002:python/', python_multi_constructor)
        
        try:
            with open('mkdocs.yml', 'r') as f:
                config = yaml.load(f, Loader=MkDocsYAMLLoader)
            print('âœ… MkDocs configuration is valid YAML')
            
            # Check required fields
            required_fields = ['site_name', 'nav', 'theme']
            missing_fields = [field for field in required_fields if field not in config]
            if missing_fields:
                print(f'âŒ Missing required fields: {missing_fields}')
                sys.exit(1)
            print('âœ… All required configuration fields present')
            
            # Additional validation
            if 'theme' in config and 'name' in config['theme']:
                print(f\"âœ… Theme configured: {config['theme']['name']}\")
            
        except Exception as e:
            print(f'âŒ Configuration validation failed: {e}')
            sys.exit(1)
        "
    
    - name: Check for broken internal links
      run: |
        echo "ðŸ”— Checking for broken internal links..."
        python -c "
        import os
        import re
        import sys
        
        def check_internal_links():
            broken_links = []
            docs_files = []
            
            # Get all markdown files
            for root, dirs, files in os.walk('docs'):
                for file in files:
                    if file.endswith('.md'):
                        docs_files.append(os.path.join(root, file))
            
            # Check each file for internal links
            for filepath in docs_files:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Find markdown links [text](path)
                links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)
                
                for link_text, link_path in links:
                    # Skip external links, anchors, and special links
                    if (link_path.startswith('http') or 
                        link_path.startswith('#') or 
                        link_path.startswith('mailto:') or
                        link_path.startswith('tel:')):
                        continue
                    
                    # Strip any anchors from the path
                    clean_path = link_path.split('#')[0] if '#' in link_path else link_path
                    
                    # Resolve relative paths
                    if clean_path.startswith('../'):
                        # Handle relative paths
                        base_dir = os.path.dirname(filepath)
                        target_path = os.path.normpath(os.path.join(base_dir, clean_path))
                    elif clean_path.startswith('./'):
                        # Handle current directory paths
                        base_dir = os.path.dirname(filepath)
                        target_path = os.path.normpath(os.path.join(base_dir, clean_path[2:]))
                    elif clean_path.startswith('/'):
                        # Handle absolute paths from docs root
                        target_path = os.path.join('docs', clean_path[1:])
                    else:
                        # Handle relative paths from current directory
                        base_dir = os.path.dirname(filepath)
                        target_path = os.path.normpath(os.path.join(base_dir, clean_path))
                    
                    # Check if target file exists
                    # Also check for directory/index.md pattern
                    if not os.path.exists(target_path):
                        # If path ends with / check for index.md
                        if clean_path.endswith('/'):
                            index_path = os.path.join(target_path, 'index.md')
                            if os.path.exists(index_path):
                                continue
                        # Check if it's a directory with index.md
                        elif os.path.isdir(target_path):
                            index_path = os.path.join(target_path, 'index.md')
                            if os.path.exists(index_path):
                                continue
                        
                        broken_links.append({
                            'file': filepath,
                            'link_text': link_text,
                            'link_path': link_path,
                            'resolved_path': target_path
                        })
            
            if broken_links:
                print('âŒ Broken internal links found:')
                for link in broken_links:
                    print(f'  {link[\"file\"]}: \"{link[\"link_text\"]}\" -> {link[\"link_path\"]} (resolved: {link[\"resolved_path\"]})')
                return False
            else:
                print('âœ… No broken internal links found')
                return True
        
        if not check_internal_links():
            sys.exit(1)
        "
    
    - name: Validate image references
      run: |
        echo "ðŸ–¼ï¸ Validating image references..."
        python -c "
        import os
        import re
        import sys
        
        def check_image_references():
            missing_images = []
            docs_files = []
            
            # Get all markdown files
            for root, dirs, files in os.walk('docs'):
                for file in files:
                    if file.endswith('.md'):
                        docs_files.append(os.path.join(root, file))
            
            for filepath in docs_files:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Find image references ![alt](path)
                images = re.findall(r'!\[([^\]]*)\]\(([^)]+)\)', content)
                
                for alt_text, img_path in images:
                    # Skip external images
                    if img_path.startswith('http'):
                        continue
                    
                    # Resolve image path
                    if img_path.startswith('../'):
                        base_dir = os.path.dirname(filepath)
                        target_path = os.path.normpath(os.path.join(base_dir, img_path))
                    elif img_path.startswith('./'):
                        base_dir = os.path.dirname(filepath)
                        target_path = os.path.normpath(os.path.join(base_dir, img_path[2:]))
                    else:
                        target_path = os.path.join('docs', img_path)
                    
                    if not os.path.exists(target_path):
                        missing_images.append({
                            'file': filepath,
                            'alt_text': alt_text,
                            'img_path': img_path,
                            'resolved_path': target_path
                        })
            
            if missing_images:
                print('âŒ Missing image files found:')
                for img in missing_images:
                    print(f'  {img[\"file\"]}: \"{img[\"alt_text\"]}\" -> {img[\"img_path\"]} (resolved: {img[\"resolved_path\"]})')
                return False
            else:
                print('âœ… All image references are valid')
                return True
        
        if not check_image_references():
            sys.exit(1)
        "
    
    - name: Build documentation
      run: |
        echo "ðŸ—ï¸ Building MkDocs documentation..."
        mkdocs build --clean --strict --verbose
        echo "âœ… Documentation build successful"
    
    - name: Test built site accessibility
      run: |
        echo "ðŸ§ª Testing site accessibility..."
        python -m http.server 8000 --directory site &
        SERVER_PID=$!
        sleep 3
        
        # Test main pages are accessible
        curl -f http://localhost:8000/ -o /dev/null -s || (echo "âŒ Homepage not accessible" && kill $SERVER_PID && exit 1)
        curl -f http://localhost:8000/search/ -o /dev/null -s || echo "âš ï¸ Search page not accessible (may be normal)"
        
        echo "âœ… Site accessibility test passed"
        kill $SERVER_PID
    
    - name: Generate build report
      if: always()
      run: |
        echo "ðŸ“Š Build Report" >> $GITHUB_STEP_SUMMARY
        echo "=============" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Documentation Statistics" >> $GITHUB_STEP_SUMMARY
        echo "- **Total Markdown files**: $(find docs/ -name '*.md' | wc -l)" >> $GITHUB_STEP_SUMMARY
        echo "- **Total Images**: $(find docs/ -type f \( -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.gif' -o -name '*.svg' \) | wc -l)" >> $GITHUB_STEP_SUMMARY
        echo "- **Site size**: $(du -sh site/ 2>/dev/null | cut -f1 || echo 'N/A')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ -d "site" ]; then
          echo "### Generated Pages" >> $GITHUB_STEP_SUMMARY
          find site/ -name "*.html" | head -10 | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          if [ $(find site/ -name "*.html" | wc -l) -gt 10 ]; then
            echo "- ... and $(( $(find site/ -name "*.html" | wc -l) - 10 )) more pages" >> $GITHUB_STEP_SUMMARY
          fi
        fi

  build:
    runs-on: ubuntu-latest
    name: Build Documentation
    needs: lint-and-test
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt
            
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          
      - name: Build MkDocs site
        run: |
          mkdocs build --clean --strict --verbose
          echo "âœ… Final build completed successfully"
        
      - name: Setup Pages
        uses: actions/configure-pages@v4
        
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./site

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to GitHub Pages
    needs: [lint-and-test, build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
    
    - name: Deployment success notification
      run: |
        echo "ðŸš€ Documentation successfully deployed!" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ“– **Live Site**: ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY

  notify:
    runs-on: ubuntu-latest
    name: Build Status Notification
    needs: [lint-and-test, build, deploy]
    if: always()
    
    steps:
    - name: Build Status Summary
      run: |
        echo "## ðŸ“‹ Build Status Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.lint-and-test.result }}" == "success" ]; then
          echo "âœ… **Linting & Testing**: Passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Linting & Testing**: Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.build.result }}" == "success" ]; then
          echo "âœ… **Build**: Passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Build**: Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "âœ… **Deployment**: Passed" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy.result }}" == "skipped" ]; then
          echo "â­ï¸ **Deployment**: Skipped (not main branch)" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Deployment**: Failed" >> $GITHUB_STEP_SUMMARY
        fi
